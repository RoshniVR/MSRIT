1- selection sort

import time
from random import randint
def selectionsort( aList ):
  for i in range( len( aList ) ):
    least = i
    for j in range( i + 1 , len( aList ) ):
      if aList[j] < aList[least]:
        least = j

    swap( aList, least, i )


def swap( A, x, y ):
  tmp = A[x]
  A[x] = A[y]
  A[y] = tmp

n=randint(10,10)
aList=[randint(0,100)for i in range(n)]
print(aList)
#seq=[21,12,51,1,6]
selectionsort(aList)
print(aList)
end=time.time()
print(end-start,"seconds")



2- stable matching

n= int(input("Enter the number of men/women:\t"))
men = dict([(input('Enter the name of man:\t').strip(), input('Enter the preference list:\n').split()[::-1]) for i in range(n)])
women = dict([(input('Enter the name of woman:\t').strip(), input('Enter the preference list:\n').split()) for i in range(n)])
pairs = {}
not_engaged = set(men)
while not_engaged:
        man = not_engaged.pop()
        if men[man] == []:
                print('No stable match exists')
                break
        woman = men[man].pop()
        if woman in pairs:
                if women[woman].index(pairs[woman]) > women[woman].index(man):
                        not_engaged.add(pairs[woman])
                        pairs[woman] = man
                else:
                        not_engaged.add(man)
        else:
                pairs[woman] = man
else:
        for i in pairs:
                print(pairs[i], 'is paired with', i)



3- insertion sort

from random import randint
def isrt(l):
        for i in range(1,len(l)):
             key=l[i]
             j=i-1
             while(l[j]>key) and (j>=0):
                   l[j+1]=l[j]
                   j-=1
             l[j+1]=key
n= randint(1,10)
l=[randint(10,100) for i in range(n)]
print(l)
isrt(l)
print(l)


4- bfs


def bfs(graph, start, path=[]):
  q=[start]
  while q:
    v=q.pop(0)  #THIS WILL DELETE FROM FRONT FROM 0th position hence will act as a queue
    if not v in path:
      path=path+[v]
      q=q+graph[v]
  return path
graph={'A':['B','S'],'B':['A'],'S':['A','C','G'],'G':['S','F','H'],'C':['S','F','D','E'],'D':['C'],'E':['C','H'],'H':['E','G'],'F':['C','G']}                                                          
print(' bfs ', bfs(graph, 'A'))

5- merge sort


import time
start=time.time()
from random import randint
def msort(list):
    print("splitting list",list);
    if len(list)>1:
        mid=len(list)//2
        lh=list[:mid]
        rh=list[mid:]
        msort(lh)
        msort(rh)
        i=0
        j=0
        k=0
        while(i<len(lh) and j<len(rh)):
            if lh[i]<rh[j]:
                list[k]=lh[i]
                i=i+1
            else:
                list[k]=rh[j]
                j=j+1
            k=k+1
        while i<len(lh):
            list[k]=lh[i]
            i=i+1
            k=k+1
        while j<len(rh):
            list[k]=rh[j]
            j=j+1
            k=k+1
    print("merging",list)
n=randint(10,100)
list=[randint(0,100) for i in range(n)]
print(list)
msort(list)
print(list)

6- counting inversions


def count(a):
    n=len(a)
    if n<2:
        return a,0
    b,p=count(a[:n//2])
    c,q=count(a[n//2:])
    b.reverse()
    c.reverse()
    p+=q
    while b and c:
        if b[-1] < c[-1]:
            a.append(b.pop())
        else:
            a.append(c.pop())
            p+=len(b)
    a+=b[::-1]+c[::-1]
    return a,p
a=[7,6,9,1,3,5,8,4,26,12]
print(a)
a,inv=count(a)
print(*a)
print(inv)

7- quick sort

def qsort(l):
    if not l:
        return []
    else:
        pivot=l[0]
        less=[x for x in l if x<pivot]
        more=[x for x in l[1:] if x>=pivot]
        return qsort(less)+[pivot]+qsort(more)
l=[33,24,54]
qsort(l)
print(qsort(l))


8- djistras

import time
start=time.time()
from heapq import*
def djik(graph,start):
    n=len(graph)
    Q=[[0,start]]
    d=[9999 for i in range(n)]
    d[start]=0
    while Q:
        [length,u]=heappop(Q)
        for v in range(n):
            if d[v]>d[u]+graph[u][v]:
                d[v]=d[u]+graph[u][v]
                heappush(Q,(d[v],v))
    return d
graph = [[0,  1,  3,  9999], [1,  0 ,1,  4],[3,  1,  0,  2], [9999,  4,  2,0]] #my graph is like G[0] will tel you dist from node 0 to all nodes. 9999 means infinty tho.
d = djik(graph, 0)
print(d)
end=time.time()
print(end-start,"seconds")

c code

#include<stdio.h> 
struct node 
{ 
unsigned dist[20]; 
unsigned from[20]; 
}rt[10]; 
int main() 
{ 
int costmat[20][20]; 
int nodes,i,j,k,count=0; 
printf("\nEnter the number of nodes : "); 
scanf("%d",&nodes);//Enter the nodes 
printf("\nEnter the cost matrix :\n"); 
for(i=0;i<nodes;i++) 
{ 
for(j=0;j<nodes;j++) 
{ 
scanf("%d",&costmat[i][j]); 
costmat[i][i]=0; 
rt[i].dist[j]=costmat[i][j];//initialise the distance equal to cost matrix 
rt[i].from[j]=j; 
} 
} 
do 
{ 
count=0; 
for(i=0;i<nodes;i++)
for(j=0;j<nodes;j++) 
for(k=0;k<nodes;k++) 
if(rt[i].dist[j]>costmat[i][k]+rt[k].dist[j]) 
{
rt[i].dist[j]=rt[i].dist[k]+rt[k].dist[j]; 
rt[i].from[j]=k;count++; 
} 
}while(count!=0); 
for(i=0;i<nodes;i++) 
{ 
printf("\n\n For router %d\n",i+1); 
for(j=0;j<nodes;j++) 
{ 
printf("\t\nnode %d via %d Distance %d ",j+1,rt[i].from[j]+1,rt[i].dist[j]); 
} 
} 
printf("\n\n"); 
}




9- prims

#include<stdio.h>
int n,cost[10][10];
void prims();
int main()
{
	int i,j;	
	// Read the number of nodes
	printf("Enter the number of nodes\n");
	scanf("%d",&n);
	printf("Enter the cost matrix\n");
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
			printf("Enter the cost between %d and %d\n",i,j);
			scanf("%d",&cost[i][j]);
		}
	}
	prims();
	return 0;
}
void prims()
{
	int i,vis[10],j,ne=0,mincost=0,u,v,min;
	//Initialize the visited array.
	for(i=1;i<=n;i++)
		vis[i]=0;
	//Mark vis of first node as 1.
	vis[1]=1;
	//Algorithm : Unless n-1 edges
	while(ne != n-1)
	{
		min=999;
		// Get the min from the cost matrix from the node that has been visited.
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=n;j++)
			{
				if(vis[i]==1)
				{
					if(cost[i][j]<min)
					{
						min=cost[i][j];
						u=i;
						v=j;
					}
				}
			}
		}
		// check whether the node 'v' is visited or not and update the mincost accordingly.
		if(vis[v]!=1)
		{
			printf("The next node from %d-------> is %d with cost %d\n",u,v,min);
			vis[v]=1;
			ne=ne+1;
			mincost=mincost+min;
		}
		//Mark cost of 'u' and 'v' to infinity.
		cost[u][v]=cost[v][u]=999;
	}// end while
	printf("The mincost is %d\n",mincost);
}




10- kruskal

#include<stdio.h>
int n,cost[10][10];
void kruskal();
int main()
{
	int i,j;	
	// Read the number of nodes
	printf("Enter the number of nodes\n");
	scanf("%d",&n);
	printf("Enter the cost matrix\n");

	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
			printf("Enter the cost between %d and %d\n",i,j);
			scanf("%d",&cost[i][j]);
		}
	}
	kruskal();
	return 0;
}

void kruskal()
{
	int i,parent[10],j,ne=0,mincost=0,u,v,min,a,b;
	//Initialize the parent array.
	for(i=1;i<=n;i++)
		parent[i]=0;
	
	//Algorithm : Unless n-1 edges
	while(ne != n-1)
	{
		min=999;
		// Get the min from the cost matrix 
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=n;j++)
			{
				
					if(cost[i][j]<min)
					{
						min=cost[i][j];
						a=u=i;
						b=v=j;
					}
				
			}
		}

		//Find the parent of each 'u' and 'v'.
		while(parent[u]!=0)
			u=parent[u];

		while(parent[v]!=0)
			v=parent[v];

		// If u!=v then no cycle in the graph
		if(u!=v)
		{
			printf("The next node from %d-------> is %d with cost %d\n",a,b,min);
			parent[v]=u;
			ne=ne+1;
			mincost=mincost+min;
		}

		//Mark cost of 'a' and 'b' to infinity.
		cost[a][b]=cost[b][a]=999;
	}// end while

	printf("The mincost is %d\n",mincost);
}		


11- knapsack
python

n, W = map(int, input("Enter the number of items and maximum weight of knapsack:\t").split())
w = []
print("Enter the weights and values:")
for i in range(n):
	w.append(tuple(map(int, input().split())))
l = [0] * (W + 1)
s = [set() for i in range(W + 1)]
for i, k in w:
	j = W
	while j >= i:
		x = max(l[j], l[j - i] + k)
		if x != l[j]:
			s[j] = s[j - i] | {(i, k)} #union of 2 sets. Note that {(i, k)} is a set and not a dictionary. {i: k} is a dict
		l[j] = x
		j -= 1
print("Maximum cost:", l[-1])
print("Items are:", *s[-1])


c code
#include<stdio.h>
int n,we[10],v[10],W,M[10][10];
void knapsack();
int max(int a,int b);
void find_solution();
int main()
{
	int i;
	//Enter the number of items
	printf("Enter the number of items\n");
	scanf("%d",&n);
	//Enter the weights of items
	printf("Enter the weights of items\n");
	for(i=1;i<=n;i++)
	{
		printf("Enter the weight of item %d\n",i);
		scanf("%d",&we[i]);
	}
	//Enter the values of the items
	printf("Enter the values of items\n");
	for(i=1;i<=n;i++)
	{
		printf("Enter the value of item %d\n",i);
		scanf("%d",&v[i]);
	}
	//Enter the Knapsack capacity
	printf("Enter the Knapsack capacity\n");
	scanf("%d",&W);
	
	knapsack();
	find_solution();
	return 0;
}

void knapsack()
{
	int i,w;
	for(i=1;i<=n;i++)	//n items
	{
		for(w=1;w<=W;w++)	// Capacity W
		{
			if(we[i]> w)
				M[i][w]=M[i-1][w];
			else
				M[i][w]=max(M[i-1][w], v[i]+M[i-1][w-we[i]]);
		}
	}
	printf("The maximum profit achievable is %d\n", M[n][W]);
}
int max(int a, int b)
{
	if(a>b)
		return a;
	else
		return b;
}


void find_solution()
{
	int i,k;
	i=n;
	k=W;
	while(i>0 && k>0)
	{
		if(M[i][k]!= M[i-1][k])
		{	
			n=i;
			printf(" The item in the knapsack is %d\n", i);
			i=i-1;
			k=k-we[n];
		}
		else
			i=i-1;
	}
}


12- wis

def getIntervals(m):
	global p, n
	j = n
	a = []
	while j:
		if m[j] == m[j - 1]:
			j -= 1
		else:
			a.append(j)
			j = p[j - 1]
	return a[::-1]

n = int(input("Enter the number of intervals:\t"))
print("Enter the intervals: (start, end, weight)")
intervals = [tuple(map(int, input().split())) for i in range(n)]
intervals.sort(key=lambda x: x[1])
p = []
for i in range(n):
	j = i
	while j >= 0 and intervals[j][1] > intervals[i][0]:
		j -= 1 #i starts before j
	p.append(j + 1)
m = [0]
for j in range(n):
	m.append(max(m[j], intervals[j][2] + m[p[j]]))
print("Maximum total weight:", m[n])
print("Intervals are:", end=" ")
for i in getIntervals(m):
	print(intervals[i - 1], end=" ")


13- bellman ford

def ini(graph,src):
    d={}
    p={}
    for node in graph:
        d[node]=9999
        p[node]=None
    d[src]=0
    return d,p
def relax(u,v,graph,d,p):
    if d[v]>d[u]+graph[u][v]:
        d[v]=d[u]+graph[u][v]
        p[v]=u
def bford(graph,src):
    d,p=ini(graph,src)
    for i in range(len(graph)-1):
        for u in graph:
            for v in graph[u]:
                relax(u,v,graph,d,p)
    return d,p

graph={'a':{'b':-4,'t':-3},'b':{'d':-1,'e':-2},'c':{'b':8,'t':3},'d':{'a':6,'t':4},'e':{'c':-3,'t':2},'t':{}}
d,p=bford(graph,'a')
print("distance is:",d)
print("predecssor is :",p)


14- tsp

#include<stdio.h>
int a[10][10],visited[10],n,cost=0;

void get()
{
	int i,j;
	printf("Enter No. of Cities: ");
	scanf("%d",&n);
	printf("\nEnter Cost Matrix\n");
	for(i=0;i < n;i++)
	{
		printf("\nEnter Elements of Row # : %d\n",i+1);
		for( j=0;j < n;j++)
			scanf("%d",&a[i][j]);
		visited[i]=0;
	}
	printf("\n\nThe cost list is:\n\n");
	for( i=0;i < n;i++)
	{
		printf("\n\n");
		for(j=0;j < n;j++)
			printf("\t%d",a[i][j]);
	}
}

void mincost(int city)
{
	int i,ncity;
	visited[city]=1;	
	printf("%d -->",city+1);
	ncity=least(city);
	if(ncity==999)
	{
		ncity=0;
		printf("%d",ncity+1);
		cost+=a[city][ncity];
		return;
	}
	mincost(ncity);
}

int least(int c)
{
	int i,nc=999;
	int min=999,kmin;
	for(i=0;i < n;i++)
	{
		if((a[c][i]!=0)&&(visited[i]==0))
			if(a[c][i] < min)
			{
				min=a[i][0]+a[c][i];
				kmin=a[c][i];
				nc=i;
			}
	}
	if(min!=999)
		cost+=kmin;
	return nc;
}

void put()
{
	printf("\n\nMinimum cost:");
	printf("%d",cost);
}

void main()
{
	//clrscr();
	get();
	printf("\n\nThe Path is:\n\n");
	mincost(0);
	put();
	//getch();
}







